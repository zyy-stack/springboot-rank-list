from typing import List, Optional
import cv2
import numpy as np


def projection_by_bboxes(boxes: np.array, axis: int) -> np.ndarray:
    """
    通过一组 bbox 获得投影直方图，最后以 per-pixel 形式输出

    Args:
        boxes: [N, 4]
        axis: 0-x坐标向水平方向投影，1-y坐标向垂直方向投影
    """
    assert axis in [0, 1]
    length = np.max(boxes[:, axis::2])
    res = np.zeros(length, dtype=int)

    # 可矢量化但这里保持简单直观
    for start, end in boxes[:, axis::2]:
        res[start:end] += 1
    return res


def split_projection_profile_zero(arr_values: np.ndarray, min_gap: int = 1):
    """
    只在投影上存在 >=2 个非零连续段时返回这些段的 (start_array, end_array)。
    否则返回 None。
    segments are half-open: [start, end)
    """
    if arr_values is None or len(arr_values) == 0:
        return None

    arr_bool = arr_values > 0
    segments = []
    in_seg = False
    start = 0
    for i, v in enumerate(arr_bool):
        if v and not in_seg:
            in_seg = True
            start = i
        elif not v and in_seg:
            in_seg = False
            segments.append((start, i))
    if in_seg:
        segments.append((start, len(arr_bool)))

    if len(segments) <= 1:
        return None

    arr_start = np.array([s for s, e in segments], dtype=int)
    arr_end = np.array([e for s, e in segments], dtype=int)
    return arr_start, arr_end


# ----------------------------
# main recursive function with row_id bookkeeping
# ----------------------------
def recursive_xy_cut_grouped(
        boxes: np.ndarray,
        indices: List[int],
        res_groups: List[dict],
        cut_history: Optional[List[str]] = None,
        row_id: Optional[int] = None,
        counters: Optional[dict] = None,
):
    """
    boxes: ndarray [M,4]
    indices: list of original indices for these boxes
    res_groups: list to append final groups. 每个元素为 dict:
        { "indices": [...], "cut_path": [...], "row_id": int|None }
    cut_history: 当前路径（用于记录切割序列）
    row_id: 如果进入过 Y 切割分段，这里会保存该分段的唯一 id，传给后代
    counters: {"row": int} 用来分配唯一 row_id（递归中共享）
    """
    if cut_history is None:
        cut_history = []
    if counters is None:
        counters = {"row": 0}

    if boxes.shape[0] == 0:
        return

    # 1) 尝试 Y（垂直）切分 —— 先按行分
    y_proj = projection_by_bboxes(boxes, axis=1)
    pos_y = split_projection_profile_zero(y_proj)

    if pos_y is not None:
        arr_y0, arr_y1 = pos_y
        # 对每个 y 段分配一个新的 row_id 并递归
        for r0, r1 in zip(arr_y0, arr_y1):
            y_mask = (boxes[:, 1] >= r0) & (boxes[:, 1] < r1)
            boxes_chunk = boxes[y_mask]
            indices_chunk = np.array(indices)[y_mask].tolist()
            # 分配 row id（每个 y chunk 一个唯一 id）
            this_row_id = counters["row"]
            counters["row"] += 1

            # 记录到 cut_path（Y）
            new_cut_history = cut_history + ["Y"]
            # 在该行内，继续递归（此时把 row_id 传下去）
            recursive_xy_cut_grouped(
                boxes_chunk,
                indices_chunk,
                res_groups,
                cut_history=new_cut_history,
                row_id=this_row_id,
                counters=counters,
            )
        return

    # 2) Y 无法切，尝试 X（水平方向）切分 —— 切出同一行内的列（同一 row_id 传递）
    x_proj = projection_by_bboxes(boxes, axis=0)
    pos_x = split_projection_profile_zero(x_proj)

    if pos_x is not None:
        arr_x0, arr_x1 = pos_x
        for c0, c1 in zip(arr_x0, arr_x1):
            x_mask = (boxes[:, 0] >= c0) & (boxes[:, 0] < c1)
            boxes_chunk = boxes[x_mask]
            indices_chunk = np.array(indices)[x_mask].tolist()

            new_cut_history = cut_history + ["X"]
            # X 切不改变 row_id（如果父层有 row_id 就继续传；否则 None）
            recursive_xy_cut_grouped(
                boxes_chunk,
                indices_chunk,
                res_groups,
                cut_history=new_cut_history,
                row_id=row_id,
                counters=counters,
            )
        return

    # 3) 无法再切，作为叶子组加入结果，携带当前 row_id 和 cut_path
    res_groups.append({
        "indices": list(indices),
        "cut_path": cut_history.copy(),
        "row_id": row_id,
    })


def points_to_bbox(points):
    assert len(points) == 8

    left = min(points[::2])
    right = max(points[::2])
    top = min(points[1::2])
    bottom = max(points[1::2])

    left = max(left, 0)
    top = max(top, 0)
    right = max(right, 0)
    bottom = max(bottom, 0)
    return [left, top, right, bottom]


def bbox2points(bbox):
    left, top, right, bottom = bbox
    return [left, top, right, top, right, bottom, left, bottom]


def vis_polygon(img, points, thickness=2, color=None):
    br2bl_color = color
    tl2tr_color = color
    tr2br_color = color
    bl2tl_color = color
    cv2.line(img, (points[0][0], points[0][1]), (points[1][0], points[1][1]), tl2tr_color, thickness)
    cv2.line(img, (points[1][0], points[1][1]), (points[2][0], points[2][1]), tr2br_color, thickness)
    cv2.line(img, (points[2][0], points[2][1]), (points[3][0], points[3][1]), br2bl_color, thickness)
    cv2.line(img, (points[3][0], points[3][1]), (points[0][0], points[0][1]), bl2tl_color, thickness)
    return img


def vis_points(img: np.ndarray, points, texts: List[str] = None, color=(0, 200, 0)) -> np.ndarray:
    points = np.array(points)
    if texts is not None:
        assert len(texts) == points.shape[0]

    for i, _points in enumerate(points):
        vis_polygon(img, _points.reshape(-1, 2), thickness=2, color=color)
        bbox = points_to_bbox(_points)
        left, top, right, bottom = bbox
        cx = (left + right) // 2
        cy = (top + bottom) // 2

        txt = texts[i]
        font = cv2.FONT_HERSHEY_SIMPLEX
        cat_size = cv2.getTextSize(txt, font, 0.5, 2)[0]

        img = cv2.rectangle(
            img,
            (cx - 5 * len(txt), cy - cat_size[1] - 5),
            (cx - 5 * len(txt) + cat_size[0], cy - 5),
            color,
            -1,
        )

        img = cv2.putText(
            img,
            txt,
            (cx - 5 * len(txt), cy - 5),
            font,
            0.5,
            (255, 255, 255),
            thickness=1,
            lineType=cv2.LINE_AA,
        )

    return img


def vis_polygons_with_index(image, points):
    texts = [str(i) for i in range(len(points))]
    res_img = vis_points(image.copy(), points, texts)
    return res_img
