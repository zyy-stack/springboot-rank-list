from typing import List
import cv2
import numpy as np


def projection_by_bboxes(boxes: np.array, axis: int) -> np.ndarray:
    """
     通过一组 bbox 获得投影直方图，最后以 per-pixel 形式输出

    Args:
        boxes: [N, 4]
        axis: 0-x坐标向水平方向投影， 1-y坐标向垂直方向投影

    Returns:
        1D 投影直方图，长度为投影方向坐标的最大值(我们不需要图片的实际边长，因为只是要找文本框的间隔)

    """
    assert axis in [0, 1]
    length = np.max(boxes[:, axis::2])
    res = np.zeros(length, dtype=int)
    # TODO: how to remove for loop?
    for start, end in boxes[:, axis::2]:
        res[start:end] += 1
    return res

def split_once_by_max_gap(arr_values: np.ndarray,
                          min_gap: int = 1,
                          gap_ratio: float = 1.5):
    """
    只在最显著的 0 低谷处分一次（最多 2 块）
    """
    arr_index = np.where(arr_values > 0)[0]
    if not len(arr_index):
        return None

    arr_diff = arr_index[1:] - arr_index[:-1]
    diff_idx = np.where(arr_diff > min_gap)[0]
    if len(diff_idx) == 0:
        return None

    gaps = arr_diff[diff_idx]

    if len(gaps) > 1:
        median_gap = np.median(gaps)
        max_gap = np.max(gaps)
        if max_gap < median_gap * gap_ratio:
            return None
        cut_pos = diff_idx[np.argmax(gaps)]
    else:
        cut_pos = diff_idx[0]

    # 显式分成两个连续区间（axis-agnostic）
    first_start = arr_index[0]
    first_end = arr_index[cut_pos] + 1

    second_start = arr_index[cut_pos + 1]
    second_end = arr_index[-1] + 1

    return (
        np.array([first_start, second_start]),
        np.array([first_end, second_end])
    )

def gap_from_pos(pos):
    if pos is None:
        return 0
    starts, ends = pos
    if len(starts) != 2:
        return 0
    return starts[1] - ends[0]
def overlap_1d(a0, a1, b0, b1):
    inter = max(0, min(a1, b1) - max(a0, b0))
    union = min((a1-a0),(b1-b0))
    return inter / union if union > 0 else 0

def group_rows_by_y_overlap(boxes, min_overlap=0.5):
    rows = []
    count=0
    for i in range(len(boxes)):
        placed = False
        for row in rows:
            j = row[0]
            if overlap_1d(boxes[i,1], boxes[i,3],
                          boxes[j,1], boxes[j,3]) >= min_overlap:
                row.append(i)
                count+=1
                placed = True
                break
        if not placed:
            rows.append([i])
            count+=1
    print(count)
    return rows

def first_column_aligned(boxes, rows, min_overlap=0.5):
    first_boxes = []

    for row in rows:
        row_sorted = sort_row_by_x(boxes, row)
        first_boxes.append(row_sorted[0])

    ref = first_boxes[0]
    for i in first_boxes[1:]:
        if overlap_1d(boxes[ref,0], boxes[ref,2],
                      boxes[i,0], boxes[i,2]) < min_overlap:
            return False

    return True

def sort_row_by_x(boxes, row):
    return sorted(row, key=lambda i: boxes[i, 0])


def row_length_consistent(rows, ratio=0.3):
    lengths = np.array([len(r) for r in rows])
    med = np.median(lengths)

    return np.all(np.abs(lengths - med) / med <= ratio)

def is_weak_grid_layout(boxes,
                        min_y_overlap=0.5,
                        min_x_overlap=0.5,
                        max_row_len_diff=1,
                        min_rows=2):
    if len(boxes) < 4:
        return False

    rows = group_rows_by_y_overlap(boxes, min_y_overlap)
    if len(rows) < min_rows:
        return False

    rows = [sort_row_by_x(boxes, r) for r in rows]

    if not row_length_consistent(rows, max_row_len_diff):
        return False

    if not first_column_aligned(boxes, rows, min_x_overlap):
        return False

    return True


def recursive_xy_cut_grouped(boxes: np.ndarray,
                             indices: List[int],
                             res_groups: List[List[int]]):

    if is_weak_grid_layout(boxes):
        res_groups.append(indices)
        return
    # 同时评估两个方向
    y_proj = projection_by_bboxes(boxes, axis=1)
    x_proj = projection_by_bboxes(boxes, axis=0)

    y_pos = split_once_by_max_gap(y_proj)
    x_pos = split_once_by_max_gap(x_proj)

    # ---------- 每一层都做方向选择 ----------
    if y_pos and not x_pos:
        axis = 1
    elif x_pos and not y_pos:
        axis = 0
    elif y_pos and x_pos:
        # 用“最大 0 低谷宽度”衡量结构断裂
        y_gap = gap_from_pos(y_pos)
        x_gap = gap_from_pos(x_pos)
        axis = 1 if y_gap >= x_gap else 0
    else:
        axis = None

    # ---------- 不可再切，收敛 ----------
    if axis is None:
        res_groups.append(indices)
        return

    # ---------- 沿选定方向切一刀 ----------
    proj = y_proj if axis == 1 else x_proj
    starts, ends = split_once_by_max_gap(proj)

    for s, e in zip(starts, ends):
        if axis == 1:
            mask = (boxes[:, 1] >= s) & (boxes[:, 3] <= e)
        else:
            mask = (boxes[:, 0] >= s) & (boxes[:, 2] <= e)

        recursive_xy_cut_grouped(
            boxes[mask],
            [indices[i] for i, m in enumerate(mask) if m],
            res_groups
        )
def robust_average_median_mad(data: List[float],threshold: float = 3.0,scale_factor: float = 1.4826,) -> float:
    """
    使用Median + MAD方法去除异常值后计算平均值
    :param data: 原始数据列表
    :param threshold: MAD倍数阈值，默认3.0（常用范围2.5-3.5）
    :param scale_factor: MAD缩放因子，默认1.4826（正态分布常数）
    :returns: 去异常后的平均值
    """
    if not data:
        return 0.0

    data_array = np.array(data)

    # 1. 计算中位数
    median = np.median(data_array)

    # 2. 计算MAD
    abs_deviation = np.abs(data_array - median)
    mad = np.median(abs_deviation)

    # 3. 如果没有变异（所有值相同），直接返回中位数
    if mad == 0:
        result = float(median)
        return result

    # 4. 使用提供的缩放因子调整MAD
    scaled_mad = mad * scale_factor

    # 5. 基于阈值过滤异常值
    mask = np.abs(data_array - median) / scaled_mad <= threshold
    filtered_data = data_array[mask]

    # 6. 计算过滤后的平均值（如果过滤后无数据，则使用中位数）
    if len(filtered_data) > 0:
        result = float(np.mean(filtered_data))
    else:
        result = float(median)

    return result

def split_once_by_max_gap(arr_values: np.ndarray,
                          min_gap: int = 1,
                          gap_ratio: float = 1.5):
    """
    只在最显著的 0 低谷处分一次（最多 2 块）
    """
    arr_index = np.where(arr_values > 0)[0]
    if not len(arr_index):
        return None

    arr_diff = arr_index[1:] - arr_index[:-1]
    diff_idx = np.where(arr_diff > min_gap)[0]
    if len(diff_idx) == 0:
        return None

    gaps = arr_diff[diff_idx]

    if len(gaps) > 1:
        # 对间隙排序
        sorted_gaps = np.sort(gaps)
        max_gap = sorted_gaps[-1]
        second_max_gap = sorted_gaps[-2]

        # 只有当最大间隙显著大于第二大间隙时才切割
        if max_gap < second_max_gap * gap_ratio:
            return None

        # 找到最大间隙在原始数组中的位置
        max_gap_idx_in_gaps = np.argmax(gaps)
        cut_pos = diff_idx[max_gap_idx_in_gaps]
    else:
        cut_pos = diff_idx[0]

    # 显式分成两个连续区间（axis-agnostic）
    first_start = arr_index[0]
    first_end = arr_index[cut_pos] + 1

    second_start = arr_index[cut_pos + 1]
    second_end = arr_index[-1] + 1

    return (
        np.array([first_start, second_start]),
        np.array([first_end, second_end])
    )


def split_blocks_once(boxes: np.ndarray,indices: List[int],axis: int,pos):
    """
    根据 split_once_by_max_gap 的结果切一次
    pos 为 None 表示不可切
    """
    if pos is None:
        return [(boxes, indices)]

    starts, ends = pos
    blocks = []

    for s, e in zip(starts, ends):
        if axis == 0:
            mask = (boxes[:, 0] >= s) & (boxes[:, 2] <= e)
        else:
            mask = (boxes[:, 1] >= s) & (boxes[:, 3] <= e)

        if np.any(mask):
            blocks.append((
                boxes[mask],
                [indices[i] for i, m in enumerate(mask) if m]
            ))

    return blocks

def xy_cut_eval_then_x_y_once(boxes: np.ndarray,indices: List[int],res_groups: List[List[int]]):
    # 同时评估两个方向
    y_proj = projection_by_bboxes(boxes, axis=1)
    x_proj = projection_by_bboxes(boxes, axis=0)
    y_pos = split_once_by_max_gap(y_proj)
    x_pos = split_once_by_max_gap(x_proj)

    #  X 切一次（或不切）
    x_blocks = split_blocks_once(boxes, indices, axis=0, pos=x_pos)

    # 对每个 X 块做一次 Y
    for xb, idxb in x_blocks:
        if y_pos is None:
            res_groups.append(idxb)
            continue

        y_proj_sub =projection_by_bboxes(xb, axis=1)
        y_pos_sub = split_once_by_max_gap(y_proj_sub)

        if y_pos_sub is None:
            res_groups.append(idxb)
            continue

        y_blocks = split_blocks_once(xb, idxb, axis=1, pos=y_pos_sub)

        for _, ids in y_blocks:
            res_groups.append(ids)
