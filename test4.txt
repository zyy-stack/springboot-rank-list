from typing import List
import cv2
import numpy as np


def projection_by_bboxes(boxes: np.array, axis: int) -> np.ndarray:
    """
     通过一组 bbox 获得投影直方图，最后以 per-pixel 形式输出

    Args:
        boxes: [N, 4]
        axis: 0-x坐标向水平方向投影， 1-y坐标向垂直方向投影

    Returns:
        1D 投影直方图，长度为投影方向坐标的最大值(我们不需要图片的实际边长，因为只是要找文本框的间隔)

    """
    assert axis in [0, 1]
    length = np.max(boxes[:, axis::2])
    res = np.zeros(length, dtype=int)
    # TODO: how to remove for loop?
    for start, end in boxes[:, axis::2]:
        res[start:end] += 1
    return res

def split_once_by_max_gap(arr_values: np.ndarray,
                          min_gap: int = 1,
                          gap_ratio: float = 1.5):
    """
    只在最显著的 0 低谷处分一次（最多 2 块）
    """
    arr_index = np.where(arr_values > 0)[0]
    if not len(arr_index):
        return None

    arr_diff = arr_index[1:] - arr_index[:-1]
    diff_idx = np.where(arr_diff > min_gap)[0]
    if len(diff_idx) == 0:
        return None

    gaps = arr_diff[diff_idx]

    if len(gaps) > 1:
        median_gap = np.median(gaps)
        max_gap = np.max(gaps)
        if max_gap < median_gap * gap_ratio:
            return None
        cut_pos = diff_idx[np.argmax(gaps)]
    else:
        cut_pos = diff_idx[0]

    # 显式分成两个连续区间（axis-agnostic）
    first_start = arr_index[0]
    first_end = arr_index[cut_pos] + 1

    second_start = arr_index[cut_pos + 1]
    second_end = arr_index[-1] + 1

    return (
        np.array([first_start, second_start]),
        np.array([first_end, second_end])
    )

def gap_from_pos(pos):
    if pos is None:
        return 0
    starts, ends = pos
    if len(starts) != 2:
        return 0
    return starts[1] - ends[0]
def overlap_1d(a0, a1, b0, b1):
    inter = max(0, min(a1, b1) - max(a0, b0))
    union = min((a1-a0),(b1-b0))
    return inter / union if union > 0 else 0

def group_rows_by_y_overlap(boxes, min_overlap=0.5):
    rows = []
    count=0
    for i in range(len(boxes)):
        placed = False
        for row in rows:
            j = row[0]
            if overlap_1d(boxes[i,1], boxes[i,3],
                          boxes[j,1], boxes[j,3]) >= min_overlap:
                row.append(i)
                count+=1
                placed = True
                break
        if not placed:
            rows.append([i])
            count+=1
    print(count)
    return rows

def first_column_aligned(boxes, rows, min_overlap=0.5):
    first_boxes = []

    for row in rows:
        row_sorted = sort_row_by_x(boxes, row)
        first_boxes.append(row_sorted[0])

    ref = first_boxes[0]
    for i in first_boxes[1:]:
        if overlap_1d(boxes[ref,0], boxes[ref,2],
                      boxes[i,0], boxes[i,2]) < min_overlap:
            return False

    return True

def sort_row_by_x(boxes, row):
    return sorted(row, key=lambda i: boxes[i, 0])


def row_length_consistent(rows, ratio=0.3):
    lengths = np.array([len(r) for r in rows])
    med = np.median(lengths)

    return np.all(np.abs(lengths - med) / med <= ratio)

def is_weak_grid_layout(boxes,
                        min_y_overlap=0.5,
                        min_x_overlap=0.5,
                        max_row_len_diff=1,
                        min_rows=2):
    if len(boxes) < 4:
        return False

    rows = group_rows_by_y_overlap(boxes, min_y_overlap)
    if len(rows) < min_rows:
        return False

    rows = [sort_row_by_x(boxes, r) for r in rows]

    if not row_length_consistent(rows, max_row_len_diff):
        return False

    if not first_column_aligned(boxes, rows, min_x_overlap):
        return False

    return True


def recursive_xy_cut_grouped(boxes: np.ndarray,
                             indices: List[int],
                             res_groups: List[List[int]]):

    if is_weak_grid_layout(boxes):
        res_groups.append(indices)
        return
    # 同时评估两个方向
    y_proj = projection_by_bboxes(boxes, axis=1)
    x_proj = projection_by_bboxes(boxes, axis=0)

    y_pos = split_once_by_max_gap(y_proj)
    x_pos = split_once_by_max_gap(x_proj)

    # ---------- 每一层都做方向选择 ----------
    if y_pos and not x_pos:
        axis = 1
    elif x_pos and not y_pos:
        axis = 0
    elif y_pos and x_pos:
        # 用“最大 0 低谷宽度”衡量结构断裂
        y_gap = gap_from_pos(y_pos)
        x_gap = gap_from_pos(x_pos)
        axis = 1 if y_gap >= x_gap else 0
    else:
        axis = None

    # ---------- 不可再切，收敛 ----------
    if axis is None:
        res_groups.append(indices)
        return

    # ---------- 沿选定方向切一刀 ----------
    proj = y_proj if axis == 1 else x_proj
    starts, ends = split_once_by_max_gap(proj)

    for s, e in zip(starts, ends):
        if axis == 1:
            mask = (boxes[:, 1] >= s) & (boxes[:, 3] <= e)
        else:
            mask = (boxes[:, 0] >= s) & (boxes[:, 2] <= e)

        recursive_xy_cut_grouped(
            boxes[mask],
            [indices[i] for i, m in enumerate(mask) if m],
            res_groups
        )
